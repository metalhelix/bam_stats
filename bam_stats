#!/usr/bin/env ruby

require 'open3'
require 'optparse'

# INPUT: directory of BAM files OR
# SINGLE bam file OR list of BAM files
#
# OUTPUT: text file with BAM file stats
# one line for each BAM file analyzed
#
VERSION = '1.2.2'

help = <<HELP
bam_stats provides a number of stats on the reads contained in a bam file. 

Basic Usage:
  bam_stats [OPTIONS] [BAM_FILES]

      BAM_FILES               Can be:
                               A single .bam file
                               A space separated list of .bam files
                               A directory with .bam files in it

Output:
   Defaults to bam_stats.txt in the same directory as the first .bam file

Options:
HELP

datums = ["name", "single_mapped_reads", "single_mapped_reads_percent", "multi_mapped_reads","multi_mapped_reads_percent", "total_alignable_reads",
          "primary_alignments", "primary_alignments_percent", "secondary_alignments", "secondary_alignments_percent", "total_alignments", "total_reads_in_bam", "unique_positions"]

datum_descriptions = <<DD
Stats File Fields:
    name              
                      Sample name. If two bam files have the same name,
                      name will be appended by incrementing integer
    single_mapped_reads
                      Number of reads from the fastq file that align 
                      to only one location in the reference genome.
                      Found by counting number of reads with NH:i:1
    single_mapped_reads_percent
                      single_mapped_reads / total_alignable_reads
    multi_mapped_reads
                      Number of reads from the fastq file that align 
                      to multiple locations in the reference genome
    multi_mapped_reads_percent
                      multi_mapped_reads / total_alignable_reads
    total_alignable_reads
                      single_mapped_reads + multi_mapped_reads

    primary_alignments
                      Count of total uniquely named alignments in bam file. 
                      Each alignable read is counted once for this measure. 
                      This is really just Total alignable reads, but 
                      described in the context of the alignment.
    secondary_alignments
                      Count of Additional alignments in bam file from 
                      multi-mapped reads.
                      Found by looking for 0x100 flag in alignments
    total_alignments
                      primary_alignments + secondary_alignments.
    total_reads_in_bam
                      Total number of lines in bam file. For a bam
                      file that does not include unaligned data, 
                      this should be the same as total_alignments
    unique_positions
                      Total number of unique alignment positions found
                      for alignments in bam file. 
                      Assumes bam file is position sorted.

DD

options = {}
options[:samtools] = `which samtools`.chomp
options[:output] = "bam_stats.txt"
options[:custom_output] = false

OptionParser.new do |opts|
  opts.banner = help

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
  opts.on("-s", "--samtools SAMTOOLS_PATH", "Specify samtools path") do |o|
    options[:samtools] = o
  end
  opts.on("-o", "--output OUTPUT_FILENAME", "Output filename") do |o|
    options[:output] = o
    options[:custom_output] = true
  end
  opts.on("-n", "--names LIST,OF,NAMES", Array, "Sample Names to Use") do |o|
    options[:names] = o
  end
  opts.on("-f", "--fastqs FASTQ,FILES", Array, "Use additional fastq file") do |o|
    options[:fastqs] = o
    options[:fastqs].each do |fastq|
      if !File.exists? o
        puts "ERROR: -f used but no valid fastq file provided"
        exit(1)
      end
    end
    ind = datums.index("total_alignable_reads")
    datums.insert(ind + 1, "total_reads")
    datums.insert(ind + 1, "not_mapped_reads")
  end
  opts.on("--unique_sequences", "enable counting unique sequences") do |o|
    require 'set'
    options[:unique_sequences] = true
    ind = datums.index("unique_positions")
    datums.insert(ind + 1, "unique_sequences")
  end
  opts.on("--table_out", "Output table to command line") do |v|
    options[:table_out] = v
  end
  opts.on("--version", "Show Version") do |h|
    puts "bam_stats: #{VERSION}"
    exit
  end
  opts.on("-h", "--help", "Show Help") do |h|
    puts opts
    puts datum_descriptions
    exit
  end
end.parse!

puts options if options[:verbose]
puts ARGV if options[:verbose]

SAMTOOLS = options[:samtools]

if SAMTOOLS.empty? or !File.exists?(SAMTOOLS)
  puts "ERROR: no samtools found"
  puts " Use -s to specify samtools location"
  exit(1)
end


inputs = ARGV
bam_files = []
if inputs.size == 0
  puts "ERROR: BAM file or directory name required"
  puts " Use -h for more information"
  exit(1)
elsif inputs.size > 1
  bam_files = inputs
elsif File.extname(inputs[0]) == ".bam"
  bam_files = [inputs[0]]
else
  bam_files = Dir.glob(File.join(inputs[0], "*.bam"))
end

if options[:fastqs] and (bam_files.size != options[:fastqs].size)
  puts "WARNING: fastq files provided, but number do not match bam files number"
  puts "  ignoring fastq files"
  options[:fastqs] = nil
end

if options[:names] and (bam_files.size != options[:names].size)
  puts "WARNING: names provided, but number do not match bam files number"
  puts "  ignoring names"
  options[:names] = nil
end

puts "Analyzing #{bam_files.size} BAM files"

if !options[:custom_output]
  output_filename = File.join(Dir.pwd, options[:output])
else
  if File.directory?(options[:output])
    output_filename = File.join(options[:output], "bam_stats.txt")
  else
    output_filename = options[:output]
  end
end

def format_number number
  formatted_number = number
  if number.to_f < 1 and number.to_f >= 0
    formatted_number = number
  else
    formatted_number = number.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
  end
  formatted_number
end

bam_data = {}
count = 1

FLAG_INDEX = 1
REF_NAME_INDEX = 2
POS_INDEX = 3
SEQ_INDEX = 9

NUM_SIG_DIGITS = 4

bam_files.each_with_index do |bam_file, bam_file_index|
  beginning_time = Time.now
  if !File.exists?(bam_file)
    puts "ERROR: cannot find bam file #{bam_file}"
    next
  end

  name = ""
  if options[:names]
    name = options[:names][bam_file_index]
  else
    name = File.basename(bam_file, File.extname(bam_file))

    # just in case multiple bam files with the same name are provided
    if bam_data[name]
      new_name = "#{name}_#{count}"
      while bam_data[new_name]
        count += 1
        new_name = "#{name}_#{count}"
      end
      name = new_name
      count = 1
    end
  end

  puts "Analyzing: #{name}"

  bam_instance_data = {}
  datums.each {|datum| bam_instance_data[datum] = 0 }
  bam_instance_data["name"] = name

  command = "#{SAMTOOLS} view #{bam_file}"
  puts command if options[:verbose]

  # keep these out of hash until very end
  # speed up is significant for not having to
  # index into hash each iteration
  total = 0
  total_aligns = 0
  primary_alignments = 0
  secondary_alignments = 0
  single_mapped_reads = 0
  multi_mapped_reads = 0
  unique_positions = 0

  last_position = ""
  unique_sequences = nil
  if options[:unique_sequences]
    unique_sequences = Set.new
  end

  Open3.popen3(command) do |i,o,e,t|
    while line = o.gets
      total += 1
      data = line.split("\t")

      flags = data[FLAG_INDEX].to_i

      # get is aligned flag
      mapped = flags & 0x4
      mapped = (mapped == 0)
      if mapped
        total_aligns += 1
      end

      # determine primary or secondary alignment
      secondary = flags & 0x100
      secondary = (secondary != 0)
      if mapped
        if secondary
          secondary_alignments += 1
        else
          primary_alignments += 1
        end
      end

      # find uniquely mapped read
      warning = false
      if(line =~ /NH:i:(\d+)/)
        number_reported_alignments = $1.to_i
        if number_reported_alignments == 1
          single_mapped_reads += 1
        elsif number_reported_alignments > 1 and !secondary
          multi_mapped_reads += 1
        end
      elsif !warning
        puts "WARNING: \"NH:i\" tag not found"
        puts "  single_mapped_reads and multi_mapped_reads calculations not correct"
        warning = true
      end

      cur_position = "#{data[REF_NAME_INDEX]}_#{data[POS_INDEX]}"
      if mapped and cur_position != last_position
        unique_positions += 1
      end
      last_position = cur_position

      if options[:verbose] and (total % 10000000 == 0)
        puts "\t#{total} Reads Analyzed"
      end

      if options[:unique_sequences]
        sequence = data[SEQ_INDEX]
        unique_sequences.add?(sequence)
      end
    end
  end

  bam_instance_data["total_reads_in_bam"] = total
  bam_instance_data["total_alignments"] += total_aligns
  bam_instance_data["primary_alignments"] = primary_alignments
  bam_instance_data["secondary_alignments"] = secondary_alignments
  bam_instance_data["single_mapped_reads"] = single_mapped_reads
  bam_instance_data["multi_mapped_reads"] = multi_mapped_reads
  bam_instance_data["unique_positions"] = unique_positions

  bam_instance_data["total_alignable_reads"] = bam_instance_data["single_mapped_reads"] + bam_instance_data["multi_mapped_reads"]
  bam_instance_data["single_mapped_reads_percent"] = (bam_instance_data["single_mapped_reads"].to_f / bam_instance_data["total_alignable_reads"]).round(NUM_SIG_DIGITS)
  bam_instance_data["multi_mapped_reads_percent"] = (bam_instance_data["multi_mapped_reads"].to_f / bam_instance_data["total_alignable_reads"]).round(NUM_SIG_DIGITS)

  bam_instance_data["primary_alignments_percent"] = (bam_instance_data["primary_alignments"].to_f / bam_instance_data["total_alignments"]).round(NUM_SIG_DIGITS)
  bam_instance_data["secondary_alignments_percent"] = (bam_instance_data["secondary_alignments"].to_f / bam_instance_data["total_alignments"]).round(NUM_SIG_DIGITS)

  if options[:fastqs]
    fastq_file = options[:fastqs][bam_file_index]
    command = "cat #{fastq_file} | wc -l"
    result = `#{command}`
    fastq_total = result.to_i / 4
    bam_instance_data["total_reads"] = fastq_total
    bam_instance_data["not_mapped_reads"] = fastq_total - (bam_instance_data["single_mapped_reads"] + bam_instance_data["multi_mapped_reads"])
  end

  if options[:unique_sequences]
    bam_instance_data["unique_sequences"] = unique_sequences.length
  end

  bam_data[name] = bam_instance_data

  if options[:verbose]
    end_time = Time.now
    puts "#{name}: #{(end_time - beginning_time).round(2)} seconds"
  end
end

# output to file
File.open(output_filename, 'w') do |file|
  file.puts datums.join("\t")
  bam_data.each do |name, values|
    out = datums.map {|d| values[d]}
    file.puts out.join("\t")
  end
end

# output to command line
if options[:table_out]
  bam_data.each do |name, values|
    format_string = datums.reduce("") {|t,v| t += "%-#{v.length + 2}s "; t}
    format_string += "\n"
    out = datums.map {|d| values[d]}
    printf format_string, *datums
    printf format_string, *out
  end
else
  bam_data.each do |name, values|
    puts "#{name}: "
    printed_datums = datums[1..-1]
    max_length = printed_datums.reduce(0) {|t,v| t = (v.length > t) ? v.length : t; t}
    printed_datums.each do |d|
      printf "    %-#{max_length + 1}s: %s\n", d, format_number(values[d])
    end
  end
end

